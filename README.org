#+title: Random Table
#+author: Jeremy Friesen
#+email: jeremy@jeremyfriesen.com
#+language: en
#+options: ':t toc:nil author:t email:t num:t
#+startup: content

 
Welcome to =random-table.el=, an Emacs package for defining random tables and rolling on them.

What is a random table?  Maybe it’s a list of given names.  And you pick a random one from that list.  Maybe it’s the creatures appearing in an RPG dungeon.

I’ve been blogging about this in my [[https://takeonrules.com/series/emacs-random-table-el-package/][Emacs random-table.el Package series]].

You may also find [[https://github.com/jeremyf/dotemacs/blob/main/emacs.d/random-tables-data.el][my random-tables-data.el]] useful for what I’ve been setting up.

* Introduction

** Features

- Composing Tables :: The results of one table could be to roll on another table or tables; and so on.
- Cached Results :: Some dice rolls inform later dice rolls.  There’s a mechanism to do that; though it likely needs improvement.
- Private Tables :: Useful when you don’t want to see the named table as an option in the =random-table/roll=; but you want to reference this table elsewhere.
- Prompt for Dice Rolls :: Random tables can encode complex procedures, and sometimes you might want to follow the procedures but provide you’re own dice rolls.
- Mad Libs Like Interpolation :: Instead of picking a table to roll on for =random-table/roll= you can type an expression (e.g. “There are {2d6} orcs”) and it will interpret that results (e.g. rolling a 6 we’d have “There are 6 orcs”).
- Inner Tables :: Within a table’s result you can have an inner table (e.g. “you meet a [brigand/priest/child/zealot/haunting nightmare]”) and the parser will pick a random element.  
- Custom “Reporter” :: By default, the results are written to the =*Messages*= buffer and added to the kill ring.  But you can configure to have a different reporter.  (see =random-table/reporter=)  
- Registering and Caching Prompt Choices :: During the life cycle of the =random-table/roll= you have access to the hash in the =random-table/roll/cache= variable.  Useful for remembering things you’ve already prompted the user for; such as their Charisma modifier.
- Extensible Parsing Logic :: The =random-table/text-replacer-functions= is a custom variable that allows for adding and removing functions to provide more extensible logic.

And more.

** Installation

As of <2023-08-21 Mon> this repository is not yet part of any of the package archive (e.g. https://melpa.org).  But you can install it via =use-package=.

#+begin_src emacs-lisp
  (use-package random-table
    :straight (:host github :repo "jeremyf/random-table.el"))
#+end_src

I have tested this using Emacs v29.1; it might work with earlier versions.

** Dependencies

I make use of the ubiquitous =s= package (See https://melpa.org/#/s) (as of <2023-08-21 Mon> that is for =s-trim=).

Originally, I relied on =org-d20= for dice rolling, but extracted the minimum viable logic for interpolating dice rolls (e.g. Evaluate “There are {1d4} doors.” to roll one four-sided die and message the string “There are 3 doors.”)


* TODO Usage

** Defining Tables

I type =M-x random-table/roll= and am prompted to give an Expression.  I can select from a pre-populated list of registered tables (via =random-table/register=).  Or I can enter an expression, such as “2d6+1” and =random-table/roll= will then evaluate the expression.

Let’s look at registering a table:

#+begin_src emacs-lisp
  (random-table/register :name "Coin Toss"
			 :data '("Heads" "Tails"))
#+end_src

When I invoke =random-table/roll=, I can select “Coin Toss”, it will add to the kill ring and write a message based on the roll; either “Heads” or “Tails”.

I could also call =random-table/roll= and provide the following: “You toss a coin and it lands on {Coin Toss}”

And will get back: “You toss a coin and it lands on Heads” (assuming you rolled a Heads).

In fact we could register a new table:

#+begin_src emacs-lisp
  (random-table/register :name "Things We Throw"
			 :data '("Rocks"
				 "Tantrum"
				 "Coin and it comes up {Coin Toss}."))
#+end_src

When we “roll” on that table, when we get the “Coin and…” result, we’ll evaluate rolling on the Coin Toss table.  The end result is “Coin and it comes up Heads.”

** Replacement Functions

In the above case the “Coin and it comes up {Coin Toss}.” replacement relies on the =random-table/text-replacer-functions=; in particular the =random-table/text-replacer-function/named-table=; which looks at the text between ={= and =}= and then uses the value between to lookup a registered table.

** Inner Tables

Instead of relying on a custom table for a coin toss, we could call =M-x random-table/roll= and provide “[heads/tails]”.  This syntax leverages the =random-table/text-replacer-function/inner-table= logic; that is interpret an inner table.  We take the text between =[= and =]= and pick one of the elements; elements are separated by a slash (e.g. =/=) character.

** Custom Rollers

We can also create ranges, but will need to consider the roller:

#+begin_src emacs-lisp
  (random-table/register :name "Reaction Roll"
			 :roller "2d6"
			 :data '(((2) . "Hostile")
				 ((3 . 5) . "Unfriendly")
				 ((6 . 8) . "Unsure")
				 ((9 . 11) . "Amicable")
				 ((12) . "Friendly")))
#+end_src

Alternatively we can use a function:

#+begin_src emacs-lisp
  (random-table/register :name "Reaction Roll"
			 :roller (lambda (&rest args) (+ 2 (random 6) (random 6)))
			 :data '(((2) . "Hostile")
				 ((3 . 5) . "Unfriendly")
				 ((6 . 8) . "Unsure")
				 ((9 . 11) . "Amicable")
				 ((12) . "Friendly")))
#+end_src

The given =:roller= is effectively two six-sided dice.  And we use the rolled values to then find the correct entry in =:data=.  For example, when we roll a 4 we’d return “Unfriendly”.

The roller can also be a named function; something you can re-use.  This is also the place where you could prompt for a modifier or a choice.

Let’s look at a more complicated example:

#+begin_src emacs-lisp
  (defun jf/2d6-plus-prompt-for-bonus (&rest args)
    (let ((modifier (read-number "Modifier: " 0)))
      (list (+ 2 modifier (random 6) (random 6)))))

  (random-table/register :name "Reaction Roll with Prompt"
			 :roller #'jf/2d6-plus-prompt-for-bonus
			 :data '(((-1000 . 2) . "Hostile")
				 ((3 . 5) . "Unfriendly")
				 ((6 . 8) . "Unsure")
				 ((9 . 11) . "Amicable")
				 ((12 . 2000) . "Friendly")))
#+end_src

In the above case, when we roll the “Reaction Roll with Prompt”, Emacs will prompt for a Modifier.  We’ll then use the given modifier to adjust the dice roll.

We could also use a registered prompt (see =random-table/prompt= docstring) and our roller could then be a sequence:

#+begin_src emacs-lisp
  (random-table/prompt "Charisma Bonus" :type #'read-number)

  (random-table/register :name "Reaction Roll with Prompt"
			 :roller '(+ "2d6" "Charisma Bonus")
			 :data '(((-1000 . 2) . "Hostile")
				 ((3 . 5) . "Unfriendly")
				 ((6 . 8) . "Unsure")
				 ((9 . 11) . "Amicable")
				 ((12 . 2000) . "Friendly")))
#+end_src

The above will add the results of rolling “2d6” to the prompt for the character’s “Charisma Bonus.”

As of <2023-09-18 Mon> , I am considering how I might represent/parse: ='(+ "2d6" (read-number "Charisma Bonus: "))=; I'm uncertain about that syntax compared to what I see as the more legible ='(+ "2d6" "Charisma Bonus")=; albeit with the need to create a prompt.

** Private Tables

As you register tables, via =random-table/register=, you add them to the table registry.  The list of tables shown in the =M-x random-table/roll= can become quite lengthy.  To register a table, without adding it to the selection list, add =:private t= as one of the key word arguments.

Below is the “Name” table.  When we roll on the “Name” table we’ll pick a random one.  Then roll on a “sub-table”.  So as to not clutter the list, we mark those “sub-tables” as =:private t=.

#+begin_src emacs-lisp
  (random-table/register :name "Name"
			 :data '("{Name > Masculine}" "{Name > Feminine}" "{Name > Non-Binary}"))

  (random-table/register :name "Name > Masculine"
			 :private t
			 :data '("George" "Michael"))

  (random-table/register :name "Name > Feminine"
			 :private t
			 :data '("Mary" "Margaret"))

  (random-table/register :name "Name > Non-Binary"
			 :private t
			 :data '("Quin" "Ash"))
#+end_src

** Storing Results for Later Use

Given the composition of tables, we may also want to store the results of the roll for future reference.  Why might we do this?  Some tables may say “Roll 3 dice.  Then on table one use the highest value.  And on table two use the lowest value.  And on table three, if there are doubles, use the number that is the “double”.

#+begin_src emacs-lisp
  (random-table/register :name "High Low"
			 :roller (lambda (&rest args) (list (+ 1 (random 6)) (+ 1 (random 6))))
			 ;; We include this so that we only return the first data element.  The
			 ;; dice rolls are for the High Value and Low Value
			 :fetcher (lambda (data roll) (car data))
			 :data '("\n- High :: {High Value}\n- Low :: {Low Value}")
			 :store t)

  (random-table/register :name "High Value"
			 :reuse "High Low"
			 :private t
			 :filter #'max
			 :data '("One" "Two" "Three" "Four" "Five" "Six"))

  (random-table/register :name "Low Value"
			 :reuse "High Low"
			 :private t
			 :filter #'min
			 :data '("One" "Two" "Three" "Four" "Five" "Six"))
#+end_src

As of 2023-08-16 I store the roll in a somewhat naive manner; for a table with =:store t=, when we “roll on that table” we add to a hash the table name and the results of the roll (e.g. the specific dice as a list).  Then until we’ve fully evaluated the roll for that table, we can reference the dice results for that table.

On 2023-09-20, I added =random-table/storage/results/get-data-value=; this function can retrieve the resolved value of the stored roll.  Where =random-table/storage/results/get= retrieves the dice results (e.g. =1= from a “1d6” roll), the =random-table/storage/results/get-data-value= interprets the =1= on from the stored table’s =data= struct.

One thing I introduced in the above was the =:fetcher= and =:filter= elements.  The =:filter= takes the dice pool (as a list) and returns an integer.  The =:fetcher= takes the integer and looks things up in the provided =:data=.

The general flow is:

- =:roll= the dice
- =:filter= the roll
- =:fetch= the filtered result

That flow is defined in =random-table/evaluate/table=.

** Encoding a Complex New Table

I set about encoding the /Death and Dismemberment/ rules for my Random Table package.

This required a few changes:

1. I needed the concept of a =current_roll=.  The /Death and Dismemberment/ table.
2. I wanted dice to be able to return strings and then use those strings as the lookup on the table’s =:data=.

I did not, at present, worry about the cumulative effects of data.  However, I’m seeing how I might do that.

Let’s dig in.

There are five tables to consider for /Death and Dismemberment/:

- Physical
- Acid/Fire
- Eldritch
- Lightning
- Non-Lethal

Here’s how I set about encoding that was as follows:

#+begin_src emacs-lisp
  (random-table/register :name "Death and Dismemberment"
    :roller #'random-table/roller/prompt-from-table-data
    :data '(("Physical" . "{Death and Dismemberment > Physical}")
	     ("Acid/Fire" . "{Death and Dismemberment > Acid/Fire}")
	     ("Eldritch" . "{Death and Dismemberment > Eldritch}")
	     ("Lightning" . "{Death and Dismemberment > Lightning}")
	     ("Non-Lethal" . "{Death and Dismemberment > Non-Lethal}")))
#+end_src

The =:roller= is a function as follows:

#+begin_src emacs-lisp
  (defun random-table/roller/prompt-from-table-data (table)
    (completing-read
     (format "%s via:" (random-table-name table))
     (random-table-data table) nil t))
#+end_src

In the case of passing the =Death and Dismemberment= table, you get the following prompt: “Death and Dismemberment via”.  And the list of options are: Physical, Acid/Fire, Eldritch, Lightning, and Non-Lethal.

Once I pick the option, I then evaluate the defined sub-table.  Let’s look at =Death and Dismemberment > Physical=.

#+begin_src emacs-lisp
  (random-table/register :name "Death and Dismemberment > Physical"
    :roller (lambda (table) (+ 1 (random 6)))
    :private t
    :data '(((1) . "Death and Dismemberment > Physical > Arm")
	     ((2) . "Death and Dismemberment > Physical > Leg")
	     ((3 . 4) . "Death and Dismemberment > Physical > Torso")
	     ((5 . 6) . "Death and Dismemberment > Physical > Head")))
#+end_src

This is a rather straight-forward table.  Let’s say the =:roller= returns a 5.  We will then evaluate the =Death and Dismemberment > Physical > Head= table; let’s look at that.  The resulting table is rather lengthy.

#+begin_src emacs-lisp
  (random-table/register :name "Death and Dismemberment > Physical > Head"
    :roller #'random-table/roller/death-and-dismemberment/damage
    :private t
    :data '(((1 . 10) . "Head Injury; Rolled {current_roll}\n- +1 Injury\n- Concussed for +{current_roll} day(s).")
	     ((11 . 15) . "Head Injury; Rolled {current_roll}\n- +1 Injury\n- Concussed for +{current_roll} day(s).\n- One Fatal Wound.\n- {Save vs. Skullcracked}")
	     ((16 . 1000) . "Head Injury; Rolled {current_roll}\n- +1 Injury\n- Concussed for +{current_roll} day(s).\n- {current_roll} - 14 Fatal Wounds.\n- {Save vs. Skullcracked}")))
#+end_src

The =:roller= (e.g. =random-table/roller/death-and-dismemberment/damage=) is as follows:

#+begin_src emacs-lisp
  (defun random-table/roller/death-and-dismemberment/damage (&rest table)
    (+ 1
       (random 12)
       (read-number "Number of Existing Injuries: " 0)
       (read-number "Lethal Damage: " 0)))
#+end_src

We roll a d12, add the number of existing injuries, and accumulated lethal damage.  Then look up the result in the =:data= of =Death and Dismemberment > Physical > Head=.  Let’s say the result is a 12.  We’ll need to roll on the the =Save vs. Skullcracked= table, which I’ve included below:

#+begin_src emacs-lisp
  (random-table/register :name "Save vs. Skullcracked"
    :roller #'random-table/roller/saving-throw
    :private t
    :data '(("Save" . "Saved against cracked skull…gain a new scar.")
	     ("Fail" . "Failed to save against cracked skull.  {Save vs. Skullcracked > Failure}")))
#+end_src

The =:roller= (e.g. =random-table/roller/saving-throw=) will prompt for the saving throw score and any modifier to the roll.  Then it will return “Fail” or “Save” depending on the results.  See the function.

#+begin_src emacs-lisp
  (defun random-table/roller/saving-throw (table)
    (let ((score (read-number (format "%s\n> Enter Saving Throw Score: " (random-table-name table)) 15))
	   (modifier (read-number (format "%s\n> Modifier: " (random-table-name table)) 0))
	   (roll (+ 1 (random 20))))
      (cond
	((= roll 1) "Fail")
	((= roll 20) "Save")
	((>= (+ roll modifier) score) "Save")
	(t "Fail"))))
#+end_src

Let’s say that we “Fail” the saving throw.  We now lookup on the =Save vs. Skullcracked > Failure= table:

#+begin_src emacs-lisp
  (random-table/register :name "Save vs. Skullcracked > Failure"
			 :private t
			 :data '("Permanently lose 1 Intelligence."
				 "Permanently lose 1 Wisdom."
				 "Permanently lose 1 Charisma."
				 "Lose your left eye. -1 to Ranged Attack."
				 "Lose your right eye. -1 to Ranged Attack."
				 "Go into a coma. You can recover from a coma by making a Con check after 1d6 days, and again after 1d6 weeks if you fail the first check. If you fail both, it is permanent."))
#+end_src

Let’s say we get “Permanently lose 1 Intelligence” for the failed save.  Now, working our way back, let’s see what that all evaluates to:

#+begin_example
Head Injury; Rolled 12
- +1 Injury
- Concussed for +12 day(s).
- One Fatal Wound.
- Failed to save against cracked skull.  Permanently lose 1 Intelligence
#+end_example

The modified d12 roll resulted in a 12; hence the +12 day(s).

** Prompting for You to Roll the dice

Let’s create a quick table:

#+begin_src emacs-lisp
  (random-table/register
     :name "Random Attribute"
     :data '("Strength"
	     "Constitution"
	     "Dexterity"
	     "Intelligence"
	     "Wisdom"
	     "Charisma"))
#+end_src

Given that I passed the universal prefix arg (e.g. =C-u=) when I roll on the =Random Attribute= table then I will get the prompt “Roll 1d6 for:” and the value I enter will be used for looking up the correct =:data= element.

In this way, you can roll the dice and use this package to encode the rules lookup.

** Exclude a Table from Prompting for a Roll

Any table that has one element in =:data= will not prompt for the roll.  Also, you can specify =:exclude-from-prompt t= when registering a table; then any “rolls” on that specific table will not prompt to give the dice value.

Ultimately, the goal is to ask for dice rolls when they might be something the player wants to roll.

** Allow for Rudimentary Math Operands with Table Results

In my quest for more random tables and functionality, I worked through Errant’s Hiring Retainers section.  Using the PC’s presence, you look-up the morale base.  Then roll 2d6, modified by the offer’s generosity, to then determine the modifier to the morale base.

To perform mathematical operations, I continue to leverage the =s-format= functionality.  That is =s-format= will evaluate and replace the text of the following format: ={text}=.

Below is the definition of a random Henchman for Errant.

#+begin_src emacs-lisp
  (random-table/register
   :name "Henchman (Errant)"
   :data '("\n- Archetype :: {Henchman > Archetype}\n- Morale :: {(Henchman > Morale Base) + (Henchman > Morale Variable)}"))
#+end_src

The ={Henchman > Archetype (Errant)}= will look on the following table:

#+begin_src emacs-lisp
    (random-table/register
     :name "Henchman > Archetype"
     :private t
     :roller #'random-table/roller/1d10
     :data '(((1 . 5) . "Warrior")
	     ((6 . 8) . "Professional")
	     ((9 . 10) . "Magic User")))
#+end_src

The ={[Henchman > Morale Base] + [Henchman > Morale Variable]}= does the following:

- Roll on =Henchman > Morale Base=
- Roll on =Henchman > Morale Variable=
- Add those two results together.  

#+begin_src emacs-lisp  
  (random-table/register
   :name "Henchman > Morale Base"
   :private t
   :roller (lambda (table) (read-number "Hiring PC's Presence Score: "))
   :data '(((3 . 4) . 5)
	   ((5 . 8) . 6)
	   ((9 . 13) . 7)
	   ((14 . 16) . 8)
	   ((17 . 18) . 9)
	   ((19 . 20) . 10)))

  (random-table/register
   :name "Henchman > Morale Variable"
   :private t
   :roller (lambda (table)
	     (let* ((options '(("Nothing" . 0) ("+25%" . 1) ("+50%" . 2) ("+75% or more" . 3)))
		    (key (completing-read "Additional Generosity of Offer: " options))
		    (modifier (alist-get key options nil nil #'string=)))
	       (+ modifier (random-table/roller/2d6 table))))
   :data '(((2) . -2)
	   ((3 . 5) . -1)
	   ((6 . 8) . 0)
	   ((9 . 11) . 1)
	   ((12 . 15) . 2)))
#+end_src

** Registering Prompts

Similar to =random-table/roller=, you can register a prompt via =random-table/prompt=.  There are common prompts (e.g. “Charisma Modifier”).  In registering a prompt, during an invocation of =random-table/roll= each prompt will only be requested once.  That is to say, the package will cache the prompt’s response and re-use that through out the roll.

This functionality leverages the per =random-table/roll= cache (as stored in the =random-table/roll/cache= variable).

#+begin_src emacs-lisp
  (random-table/prompt "Charisma Modifier"
		       :type #'read-number
		       :default 0)

  (random-table/register :name "Reaction Roll"
			 :roller (lambda (table)
				   (+ (random-table/prompt "Charisma Modifier")
				      (random-table/roller/2d6))))
#+end_src

Why include the caching?  In reviewing Kevin Crawford’s [Scarlet Heroes](https://www.drivethrurpg.com/product/127180/Scarlet-Heroes?affiliate_id=318171) there’s a table for reaction rolls that asks for a few modifiers, the rolls on one table, and one result is to roll on another table using those same modifiers.

** Testing All of This

I have added the non-interactive =random-table/roll/test-all= function; this will roll once on each of the registered non-private tables and report the results.  I've found it most useful when testing notable refactoring; namely how I handle the =:roller= slot for a =random-table=.


* The Code

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
  ;;; random-table.el --- Roll on some tables. -*- lexical-binding: t -*-

  ;;; Metadata
  ;;
  ;; Copyright (C) 2023 Jeremy Friesen
  ;; Author: Jeremy Friesen <jeremy@jeremyfriesen.com>
  ;; Version: 0.6.0
  ;; Package-Requires: ((emacs "29.1"))
  ;;
  ;;; License
  ;;
  ;; This file is NOT part of GNU Emacs.
  ;;
  ;; This program is free software: you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  ;;
  ;;; Code:
#+end_src

** Primary Functions
There are four primary functions:

- =random-table/register= :: A function for naming and defining the tables.
- =random-table/roll= :: An interactive function to select a table on which to roll.
- random-table/prompt :: A function for naming and referencing different prompts.  i.e. For old school adventuring, when you roll a Reaction Roll, you want to prompt for the current “Charisma Modifier”.
- =random-table/parse= :: This parses the provided text, thus allowing for composition of multiple tables.

*** =random-table/register=

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
  (cl-defstruct random-table
    "The definition of a structured random table.

    I roll the dice, filter the results, and fetch from the table.
    The `random-table/evaluate/table' defines the steps we take to
    \"roll on the table.\"

    The slots are:

    - :name :: the human readable and reference-able name (used for
	       completing read and the key for the table storage).
    - :data :: the tabular data, often as a list of strings.  By
	       design, those list of strings can have interpolation
	       (e.g. \"${2d6}\" both of dice structures but also of
	       other tables.
    - :roller :: this is what we roll, see `random-table/roll-on'
    - :filter :: function to filter the list of dice.

    - :fetcher :: function that takes two positional arguments (see
		  `random-table/fetcher/default'.); it is used to
		  fetch the correct entry from the table.
    - :exclude-from-prompt :: when true, ignore the prefix arg for
			      prompting for dice roll. (see
			      `random-table/roller')
    - :private :: when true, do not show in list of rollable tables.

    - :store :: When non-nil, we store the roller's value for the
		duration of the table evaluation.  Useful for when
		you have one roll that you use for multiple tables.
    - :reuse :: the :name of a table's stored dice results.

    About :reuse and :store

    There are cases where we want to use one set of dice roles.  For
    example, in the \"Oracle (Black Sword Hack)\" table we roll dice
    and use those dice results to determine both the answer as well
    as whether there are unexpected events.  All from the same roll."
    name
    data
    (roller #'random-table/roller/default)
    ;; TODO: Filter should take a table
    (filter #'random-table/filter/default)
    ;; TODO: Fetcher should take a table
    (fetcher #'random-table/fetcher/default)
    (exclude-from-prompt nil)
    (private nil)
    (store nil)
    (reuse nil))
#+end_src

Given that there is more than one table, we need to store these tables in memory.  

  #+begin_src emacs-lisp :tangle "random-table.el" :results none 
  (defvar random-table/storage/tables
    (make-hash-table :test 'equal)
    "A hash-table of random tables.

  The hash key is the \"human readable\" name of the table (as a symbol).
  The hash value is the contents of the table.")
#+end_src

We don’t want to allow for any “random” name for tables.  We can also do some pre-processing on that table.

  #+begin_src emacs-lisp :tangle "random-table.el" :results none
  (cl-defun random-table/register
      (&rest kws &key name data exclude-from-prompt &allow-other-keys)
    "Store the DATA, NAME, and all given KWS in a `random-table'."
    ;; We need to guard for a reserved character; which we use for operations.
    (if (string-match-p "[{}\]\[)(/\+\-\*]" name)
	(user-error (concat "Attempt to register \"%s\" table failed.  "
			    "You cannot include the following characters:  "
			    "\"{\", \"}\", \"[\", \"]\", \"(\", \")\", \"/\", "
			    "\"*\", \"-\", \"+\".")
		    name)
      (let* ((struct (apply #'make-random-table
			    :name name
			    ;; When there's only one possible result, don't prompt
			    ;; the user when they chose the "I'll roll my own
			    ;; dice" option.
			    :exclude-from-prompt (or exclude-from-prompt
						     (= 1 (length (-list data))))
			    :data (-list data) kws)))
	(puthash name struct random-table/storage/tables))))
#+end_src
*** =random-table/roll=

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  ;;;; Interactive
  ;;;###autoload
  (defun random-table/roll (text)
    "Evaluate the given TEXT by \"rolling\" it.

  This can either be a named table or a general text (e.g. 2d6).
  Or a combination of multiple tables.

  When you pass the universal prefix arg, you'll be prompted to
  physically roll dice for the various tables.

  When you pass \"2d6\" and pass the universal prefix arg, you will
  not be prompted to roll \"2d6\" dice, it rolls that.  In other
  words, giving dice expressions in text will not prompt you to
  roll them.

  We report that function via `random-table/reporter'.

  With each invocation of `random-table/roll' we assign a new empty
  hash table to `random-table/storage/results'."
    (interactive (list (completing-read "Expression: "
					random-table/storage/tables
					;; Predicate that filters out non-private
					;; tables.
					(lambda (name table &rest args)
					  (not (random-table-private table))))))
    (setq random-table/storage/results (make-hash-table :test 'equal))
    ;; TODO: Consider allowing custom reporter as a function.  We already
    ;; register it in the general case.
    (let ((result (funcall random-table/reporter
			   text
			   (random-table/parse text))))
      (setq random-table/storage/results nil)
      result))
#+end_src

**** =random-table/roll-region=
#+begin_src emacs-lisp :tangle "random-table.el" :results none
  ;;;###autoload
  (defun random-table/roll-region (&optional prefix)
    "Roll region or current line.

  When PREFIX is given replace the marked text."
    (interactive "P")
    (let ((random-table/reporter/format-function (lambda (e r) (format "%s" r)))
	  (random-table/reporter #'random-table/reporter/as-kill-and-message)
	  (text (if (region-active-p)
		    (buffer-substring-no-properties
		     (region-beginning) (region-end))
		  (apply #'buffer-substring-no-properties
			 (save-excursion
			   (goto-char (point-at-bol))
			   (skip-syntax-forward " " (point-at-eol))
			   (let ((beg (point)))
			     (goto-char (point-at-eol))
			     (skip-syntax-backward " " (point-at-bol))
			     (list beg (point)))))))
	  (current-prefix-arg nil))
      (let ((result (random-table/roll text)))
	(when (and prefix (region-active-p))
	    (delete-region (region-beginning) (region-end))
	    (insert result)))))
#+end_src

*** =random-table/prompt=

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (cl-defun random-table/prompt (name &key type range default)
    "Prompt for the given NAME.

  Re-use the cached prompted answer or use the
  `random-table/prompt/registry' to evaluate the prompt; then cache
  that result."
    (if type
	(random-table/prompt/put name
				 (let ((prompt (format "%s: " name)))
				   (cond
				    ((eq type 'bound-integer-range)
				     `(random-table/completing-read/integer-range
				       ,prompt ,range))
				    ((eq type #'read-number)
				     `(read-number ,prompt ,default))
				    ((eq type #'completing-read)
				     `(random-table/completing-read/alist
				       ,prompt ,range nil t))
				    (t (user-error
					"Unknown type %s function for %s registry"
					type name)))))
      (let ((value (or (random-table/storage/results/get-rolled-value name)
		       (apply (random-table/prompt/get name)))))
	(random-table/storage/results/put-rolled-value name value)
	value)))
#+end_src

Support functions for accessing the =random-table/prompt=.

#+begin_src emacs-lisp :tangle "random-table.el" :results none
(defvar random-table/prompt/registry
  (make-hash-table :test 'equal)
  "Stores the prompts registered by `random-table/prompt/register'.")

(defun random-table/prompt/get (name)
  (gethash name random-table/prompt/registry))

(defun random-table/prompt/put (name value)
  (puthash name value random-table/prompt/registry))
#+end_src

*** =random-table/parse=

** Parsing the Text

The =random-table/parse= function is responsible for transforming the given text, by replacing tables and dice expressions.

The parsing is done by sequentially calling a list of functions; each created by the =random-table/create-text-replacer-function= macro.

*** Replacer Functions

**** Supporting Macro

The =random-table/create-text-replacer-function= macro helps ensure a consistent method interface; see [[https://takeonrules.com/2023/12/17/introducing-extensibility-with-a-macro-a-list-and-a-reducer/][Introducing Extensibility with a Macro, a List, and a Reducer]].

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (cl-defmacro random-table/create-text-replacer-function
      (docstring &key name replacer regexp)
    "Create NAME function as a text REPLACER for REGEXP.

  - NAME: A symbol naming the replacer function.
  - REPLACER: A lambda with a number of args equal to one plus the number of
	      capture regions of the REGEXP.  The first parameter is the original
	      text, the rest are the capture regions of the REGEXP.
  - REGEXP: The regular expression to test against the given text.
  - DOCSTRING: The docstring for the newly created function.

  This macro builds on the logic found in `s-format'"
    (let ((name (if (stringp name) (intern name) name)))
      `(defun ,name (text)
	 ,docstring
	 (let ((saved-match-data (match-data)))
	   (unwind-protect
	       (replace-regexp-in-string
		,regexp
		(lambda (md)
		  (let ((capture-region-text-list
			 ;; Convert the matched data results into a list, with the
			 ;; `car' being the original text and the `cdr' being a
			 ;; list of each capture region.
			 (mapcar (lambda (i) (match-string i md))
				 (number-sequence 0 (- (/ (length (match-data)) 2)
						       1))))
			(replacer-match-data (match-data)))
		    (unwind-protect
			(let ((replaced-text
			       (cond
				(t
				 (set-match-data saved-match-data)
				 (apply ,replacer capture-region-text-list)))))
			  (if replaced-text
			      (format "%s" replaced-text)
			    (signal 's-format-resolve md)))
		      (set-match-data replacer-match-data))))
		text t t)
	     (set-match-data saved-match-data))))))
#+end_src

**** Inner Table

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (random-table/create-text-replacer-function
   "Conditionally replace inner-table for TEXT.

  Examples of inner-table are:

  - \"[dog/cat/horse]\" (e.g. 3 entries)
  - \"[hello world/good-bye mama jane]\" (2 entries)

  This skips over inner tables that have one element (e.g. [one])."
   :name random-table/text-replacer-function/inner-table
   :regexp "\\[\\([^\]]+/[^\]]+\\)\\]"
   :replacer (lambda (matching-text inner-table)
	       (seq-random-elt (s-split "/" inner-table))))
#+end_src

**** Table with Math

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (random-table/create-text-replacer-function
   "Conditionally perform math operation on table results for TEXT.

  Examples of math operation:

  - \"{(Henchman > Morale Base) + (Henchman > Morale Variable)}\""
   :name random-table/text-replacer-function/table-math
   :regexp "{(\\([^)]*\\))\s*\\([\-+\*]\\)\s*(\\([^)]*\\))}"
   :replacer (lambda (matching-text left-operand operator right-operand)
	       (format "%s" (funcall
			     (intern operator)
			     (string-to-number
			      (random-table/parse
			       (string-trim left-operand)))
			     (string-to-number
			      (random-table/parse
			       (string-trim right-operand)))))))
#+end_src

**** Current Roll

Throughout the rolling sequence, we keep track of what was just rolled.

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (defvar random-table/current-roll
    nil
    "The most immediate and current stored roll.")
#+end_src

#+begin_src emacs-lisp :tangle "random-table.el" :results none
    (random-table/create-text-replacer-function
     "Conditionally replace TEXT with the current roll.

    Examples of current roll:

    - \"{ CURRENT_ROLL }\"
    - \"{CURRENT_ROLL}\"

    See `random-table/current-roll'."
     :name random-table/text-replacer-function/current-roll
     :regexp "{\\(\s*CURRENT_ROLL\s*\\)}"
     :replacer (lambda (matching-text current)
		 (or random-table/current-roll matching-text)))
	       #+end_src

**** Dice Expression

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (random-table/create-text-replacer-function
   "Conditionally replace dice-expression of TEXT.

  Examples:

  - \"{1d6}\"
  - \"{2d6 + 3}\"
  - \"{ d6+3 }\"
  "
   :name random-table/text-replacer-function/dice-expression
   :regexp "{\s*\\([1-9][[:digit:]]*d[[:digit:]]+\\)\s*\\([+-][0-9]+\\)?\s*}"
   :replacer (lambda (matching-text dice &optional modifier)
	       (format "%s" (random-table/dice/roll (concat dice modifier)))))
#+end_src

**** From Interactive Prompt

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (random-table/create-text-replacer-function
   "Conditionally replace TEXT with roll on table.

  The regexp will match the entire line and attempt a direct lookup
  on the tables; failing that it will attempt to evaluate as a dice expression

  See `random-table/dice/regex' for matching dice expressions."
   :name random-table/text-replacer-function/from-interactive-prompt
   :regexp "^\\(.+\\)$"
   :replacer (lambda (matching-text table-name)
	       (if-let ((table (random-table/fetch
				(string-trim table-name) :allow_nil t)))
		   (random-table/evaluate/table table)
		 (if (string-match-p random-table/dice/regex
				     (string-trim matching-text))
		     (random-table/dice/roll (string-trim matching-text))
		   matching-text))))
#+end_src

**** Named Table

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (random-table/create-text-replacer-function
   "Conditionally replace TEXT with roll on table.

  Examples:

  - \"{Name (d2)}\"."
   :name random-table/text-replacer-function/named-table
   :regexp "{\s*\\([^})]+\\)\s*\\((\\([^)]+\\))\\)?\s*}"
   :replacer (lambda (matching-text table-name &optional has-roller roller)
	       (if-let ((table (random-table/fetch
				(string-trim table-name) :allow_nil t)))
		   (random-table/parse
		    (random-table/evaluate/table table roller))
		 matching-text)))
#+end_src

*** Specifying Replacer Functions

The =random-table/text-replacer-functions= 

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (defcustom random-table/text-replacer-functions
    '(random-table/text-replacer-function/current-roll
      random-table/text-replacer-function/dice-expression
      random-table/text-replacer-function/from-interactive-prompt
      random-table/text-replacer-function/named-table
      random-table/text-replacer-function/inner-table
      random-table/text-replacer-function/table-math)
    "Functions take on string parameter and return a string.

  The function is responsible for finding and replacing any matches
  within the text.

  See `random-table/create-text-replacer-function' macro for
  creating one of these functions."
    :group 'random-table
    :package-version '(random-table . "0.4.0")
    :type '(list :value-type (group function)))
#+end_src

*** =random-table/parse=

The =random-table/parse= function processes the list of functions.

- =(random-table/parse "[Hello/Good-bye]")= :: pick either Hello or Good-bye.
- =(random-table/parse "{ 2d6 }")= :: roll 2 six-sided dice.

#+begin_src emacs-lisp :tangle "random-table.el" :results none
  (defun random-table/parse (text)
    "Roll the given TEXT.

  This is done by formatting the given text and passing it to each
  of the functions listed in `random-table/text-replacer-functions'."
    (let ((given-text (format "%s" text)))
      (cl-reduce (lambda (string el) (funcall el string))
		 random-table/text-replacer-functions
		 :initial-value given-text)))
#+end_src

** Supporting Variables/Functions

*** Storing Results

I want to store, for later reference, the results of rolls on a table.

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
  (defvar random-table/storage/results
    (make-hash-table :test 'equal)
    "An ephemeral storage for various results of rolling.

  As part of the rolling, we both add to and remove those stored
  values; that is to say functions are responsible for clean-up.
  See `random-table' for discussion about storage and reuse.")

  (defun random-table/storage/results/put-rolled-value (name value)
    (puthash name value random-table/storage/results))

  (defun random-table/storage/results/get-rolled-value (name)
    (gethash name random-table/storage/results))
#+end_src


*** Rolling Some Actual Dice

Ultimately, we need to roll some dice.  Actual, virtual, polyhedrals.

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
(defvar random-table/dice/regex
  "^\\([0-9]*\\)?d\\([0-9]*\\)\\([+-][0-9]*\\)?")

;;; Dice String Evaluator
;;
;; The following code (with the function name prefix of \"random-table/dice\"
;; is derived from Pelle Nilsson's decide.el package
(defun random-table/dice/roll (spec-string)
  "Evaluate the given SPEC-STRING by parsing as a dice expression."
  (if (string= "d66" spec-string)
      (+ (* 10 (+ 1 (random 6))) (+ 1 (random 6)))
    (apply #'random-table/dice/roll-spec
	   (random-table/dice/parse-spec spec-string))))

(defun random-table/dice/parse-spec (spec)
  "Convert SPEC to list:

   - Number of dice
   - Face
   - Adder

  e.g. \"1d6\" -> (1 6 0) or \"2d10+2\" -> (2 10 2)"
  (when (string-match
	 "^\\([0-9]*\\)?d\\([0-9]*\\)\\([+-][0-9]*\\)?"
	 spec)
    (list (random-table/dice/string-to-number
	   (match-string 1 spec) 1)
	  (random-table/dice/string-to-number
	   (match-string 2 spec) 6)
	  (random-table/dice/string-to-number
	   (match-string 3 spec) 0))))

(defun random-table/dice/string-to-number (spec default)
  "Convert the SPEC (and DEFAULT) into an integer."
  (let ((n (if (stringp spec)
	       (string-to-number spec)
	     0)))
    (cond ((null spec) default)
	  ((> n 0) n)
	  ((string= "" spec) default)
	  ((string= "+" spec) 0)
	  ((string= "-" spec) 0)
	  (t spec))))

(defun random-table/dice/roll-spec (number-dice faces modifier)
  "Roll the NUMBER-DICE each with FACES number of sides and add MODIFIER."
  (let ((amount modifier))
    (dotimes (i number-dice)
      (setq amount (+ amount 1 (random faces))))
    amount))
#+end_src

*** Reporter

When you roll on tables, you need to output that information.  This is done via the =random-table/reporter=.

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
(defcustom random-table/reporter
  #'random-table/reporter/as-kill-and-message
  "The function takes two positional parameters:

- EXPRESSION :: The text to evaluate for \"rolling\"
- RESULT :: The results of those rolls.

See `random-table/reporter/as-kill-and-message'."
  :group 'random-table
  :package-version '(random-table . "0.1.0")
  :type '(choice
	  (function-item :tag "Kill and Message"
			 random-table/reporter/as-kill-and-message)
	  (function-item :tag "Insert"
			 random-table/reporter/as-insert)))

(defvar random-table/reporter/format-function
  (lambda (expression results) (format "- %s :: %s" expression results))
  "The configured function takes two positional arguments:

- expression :: the initial text provided `random-table/roll'
- restults :: the transformed results by replacing the table declarations with
	      their rolled results.

I structure my results in an `org-mode' definition list format.")

(defun random-table/reporter/as-kill-and-message (expression results)
  "Report RESULTS of EXPRESSION as `message' and `kill'.

See `random-table/reporter'."
  (let ((text (funcall random-table/reporter/format-function
		       expression results)))
    (kill-new text)
    (message text)))

(defun random-table/reporter/as-insert (expression results &optional buffer)
  "Insert RESULTS of EXPRESSION into BUFFER.

See `random-table/reporter'."
  (with-current-buffer (or buffer (current-buffer))
    (end-of-line)
    (insert (funcall random-table/reporter/format-function
		     expression results))))
#+end_src

** Code

#+begin_src emacs-lisp :tangle "random-table.el" :results none 
  (cl-defun random-table/fetch (value &key allow_nil)
    "Coerce the given VALUE to a registered `random-table'.

  When the given VALUE cannot be found in the
  `random-table/stroage/tables' registry we look to ALLOW_NIL.

  When ALLOW_NIL is non-nil, we return nil when no table is found
  in `random-table/stroage/tables' registry.

  When ALLOW_NIL is nil we raise an `error' when no table was
  found in the `random-table/stroage/tables' registry."
    (if-let ((table (cond
		     ((random-table-p value)
		      value)
		     ((stringp value)
		      (gethash value random-table/storage/tables))
		     ((integerp value)
		      nil)
		     (t
		      (error (concat "Expected %s to be a `random-table', "
				     "`symbol', `integer', or `string' got %s")
			     value
			     (type-of value))))))
	table
      (unless allow_nil
	(error "Could not find table %s; use `random-table/register'" value))))

  (defun random-table/roll-on (table &optional roller)
    "Roll on the TABLE with the ROLLER.

  When no ROLLER is specified, use `random-table-roller' to find
  the configured roller.

  See `random-table'."
    (if-let ((roller (or roller (random-table-roller table))))
	(cond
	 ((functionp roller) (funcall roller table))
	 ((stringp roller) (random-table/roller/string roller))
	 ((seqp roller) (random-table/roller/seq roller))
	 (_ (user-error "Unable to handle %S roller for %s table"
			roller
			(random-table-name table))))
      (user-error "Expected given %s to have roller; got nil"
		  (random-table-name table))))

  (defun random-table/roller/default (table)
    "Randomly roll on the TABLE."
    ;; Constant off by one errors are likely
    (let ((faces (length (-list (random-table-data table)))))
      (if (and current-prefix-arg
	       (not (random-table-exclude-from-prompt table)))
	  (read-number (format "Roll 1d%s for %s: "
			       faces (random-table-name table)))
	(+ 1 (random faces)))))

  (defun random-table/roller/string (text)
    "Interpolate given TEXT as a roller."
    (if (or (string= "d66" (string-trim text))
	    (string-match-p random-table/dice/regex text))
	(if current-prefix-arg
	    (read-number (format "Roll %s: " text))
	  (string-to-number
	   (format "%s" (random-table/dice/roll (string-trim text)))))
      (random-table/parse text)))

  (defun random-table/roller/seq (seq)
    "Interpolate given SEQ as a roller."
    (let ((func (car seq))
	  (rolls (mapcar
		  (lambda (text)
		    (let ((value (if (random-table/prompt/get text)
				     (random-table/prompt text)
				   (random-table/roller/string text))))
		      (string-to-number (format "%s" value))))
		  (cdr seq))))
      (apply func rolls)))

  (defun random-table/filter/default (&rest rolls)
    "Filter the given ROLLS and return an integer.

  See `random-table/roller/default'."
    (cond
     ;; Allows us to have table entries that are named.
     ((stringp (car rolls)) (car rolls))
     (t (apply #'+ (-list rolls)))))

  (defun random-table/fetcher/default (data &optional roll)
    "Find ROLL on the given table's DATA.

  When ROLL is not given, choose a random element from the TABLE."
    (if-let ((index (if (integerp roll) roll (car roll))))
	;; Sniff out if the first element to see if we're dealing with a table
	;; that has ranges.
	(if (-cons-pair? (car data))
	    ;; We have a cons-pair, meaning we have multiple rolls mapping to the
	    ;; same result.
	    (cdr (seq-find
		  (lambda (row)
		    (if (-cons-pair? row)
			(let ((range (car row)))
			  (cond
			   ((-cons-pair? range)
			    (and (>= index (car range)) (<= index (cdr range))))
			   ((listp range)
			    (member index range))
			   ((integerp range)
			    (= index range))
			   ((stringp range)
			    (string= index range))
			   (t
			    (error (concat "Expected `cons', `list', `string' or "
					   "`integer' got %s for row %S.")
				   (type-of range) row))))
		      (member index (car row))))
		  data))
	  ;; Off by one errors are so very real.
	  (nth (- index 1) data))
      (seq-random-elt data)))


  (defun random-table/evaluate/table (table &optional roller)
    "Evaluate the random TABLE, optionally using the given ROLLER.

  See `random-table' structure."
    (let* ((rolled (random-table/evaluate/table/roll table roller)))
      ;; TODO: This is wildly naive.  Perhaps the current_roll needs to be
      ;; replaced with the "${Current Roll for [My Tablename]}".  Then we can
      ;; Cache that rolled value and retrieve it.
      (setq random-table/current-roll rolled)
      (let ((results (random-table/evaluate/table/fetch-rolled-value
		      table rolled)))
	(setq random-table/current-roll nil)
	results)))

  (defun random-table/evaluate/table/roll (table &optional roller)
    "Roll on the TABLE, conditionally using ROLLER.

  This function favors re-using and caching values.

  Why cache values?  Some tables you roll one set of dice and then
  use those dice to lookup on other tables."
    (let ((results
	   (or (when-let ((reuse-table-name (random-table-reuse table)))
		 (or
		  (random-table/storage/results/get-rolled-value reuse-table-name)
		  (random-table/roll-on
		   (random-table/fetch reuse-table-name) roller)))
	       (random-table/roll-on table roller))))
      (when (random-table-store table)
	(random-table/storage/results/put-rolled-value
	 (random-table-name table) results))
      results))

  (defun random-table/evaluate/table/fetch-rolled-value (table rolled)
    "Fetch the ROLLED value from the TABLE's :data slot."
    (let* ((table (random-table/fetch table))
	   (data (random-table-data table))
	   (filtered (apply (random-table-filter table) (-list rolled)))
	   (row (if filtered
		    (funcall (random-table-fetcher table) data (-list filtered))
		  nil)))
      (or (when row (random-table/parse row)) "")))

  (defun random-table/completing-read/alist (prompt alist &rest args)
    "Like `completing-read' but PROMPT to find value in given ALIST.

  ARGS are passed to `completing-read'."
    (alist-get (apply #'completing-read prompt alist args)
	       alist nil nil #'string=))

  (defun random-table/completing-read/integer-range (prompt range)
    "Like `completing-read' but PROMPT to find integer value in RANGE."
    (let ((strings (mapcar #'number-to-string range)))
      (string-to-number (completing-read prompt strings nil t))))



  (defun random-table/roll/test-all ()
    "A convenience function to test all of the public `random-table' entries."
    (maphash (lambda (key table)
	       (unless (random-table-private table)
		 (message "Testing %s table" key)
		 ;; The test does not call these interactively, but the methods
		 ;; assume a current-prefix-arg
		 (funcall #'random-table/roll (random-table-name table))))
	     random-table/storage/tables))

  (provide 'random-table)
  ;;; random-table.el ends here
#+end_src


* Updates

** 2023-12-02 Update

During [[https://emacsconf.org/2023/][Emacs Conf 2023]] I watched Howard Abrams’s presentation [[https://emacsconf.org/2023/talks/solo/][How I play TTRPGs in Emacs]].  And I suspect I’ll be migrating to that.  What I have works well, but there’s quite a bit I’m loving about what I saw.  In particular, having the tables be their own files creates several affordances.  Namely sharing those text-based files and repurposing plain-text.

Also, if I’m going to spend effort on the functionality, I’d love to be collaborating.  So we’ll see.

My plan is to start converting my tabular data to the plain text formats of the [[https://gitlab.com/howardabrams/emacs-rpgdm][rpgdm package]].

** 2023-12-17 Update

I have looked at Howard Abram’s [[https://gitlab.com/howardabrams/emacs-rpgdm][rpgdm package]] and later [[https://codeberg.org/howardabrams/emacs-rpgtk/][rpgtk package]] for inspiration and adoption consideration.  However, I have settled on my current approach.  In part due to the feature comparisons:

| Feature                                                                                                                    | RPGDM/RPGTK | random-tables |
|----------------------------------------------------------------------------------------------------------------------------+-------------+---------------|
| Automatic dice evaluation (e.g. “There are 2d6 giants” will always roll the 2d6)                                           | ✔           | -             |
| Caching prompt choices; remembering the Charisma Modifier                                                                  | -           | ✔             |
| Caching rolls for later reference                                                                                          | -           | ✔             |
| Complex dice rollers  (e.g. 2d6 + Charisma Modifier + Situational Modifier)                                                | -           | ✔             |
| Conditional dice evaluation (e.g. “2d6” in a table is not evaluated, but “{2d6}” is)                                       | -           | ✔             |
| Custom reporter; configure how you report the results of a roll                                                            | -           | ✔             |
| Evaluate text region and roll                                                                                              | -           | ✔             |
| Evaluating dice within a result                                                                                            | ✔           | ✔             |
| Extensible parser functions                                                                                                | -           | ✔             |
| Inner tables (e.g. “You meet a [dragon/knight/peasant]”)                                                                   | ✔           | ✔             |
| Lazy load tables                                                                                                           | ✔           | -             |
| Load text tables (e.g. org-mode, plain text, markdown)                                                                     | ✔           | -             |
| Mathematical operations of table results                                                                                   | -           | ✔             |
| Multiline output (e.g. table results can include =\n=)                                                                       | -           | ✔             |
| Private tables                                                                                                             | -           | ✔             |
| Prompt for table evaluated as a “roll” (e.g. I can input “There are {2d6} [giants/frogmen/hermits]” into the table prompt) | -           | ✔             |
| Prompting to provide own dice roll                                                                                         | -           | ✔             |
| Results of a roll can then roll on more tables                                                                             | ✔           | ✔             |
| Rolled dice overview; the results of each dice and the sum                                                                 | ✔           | -             |
|----------------------------------------------------------------------------------------------------------------------------+-------------+---------------|

I provide the above feature comparison not to diminish the excellent work of Howard, as both of his above packages provide other dice rolling adjacent functionality as well as allow for loading plain text data as a table; a feature that should not be discredited in it’s friendliness as well as greater shareability.

